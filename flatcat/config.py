from __future__ import annotations
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional

import sys

if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomli as tomllib
    except ImportError:
        tomllib = None

DEFAULT_CONFIG = "flatcat.toml"


@dataclass
class Filters:
    include: List[str] = field(default_factory=list)
    exclude: List[str] = field(
        default_factory=lambda: [
            # Version control
            ".git", ".git/**", ".svn/**", ".hg/**",
            
            # Python
            "**/__pycache__/**", "venv/**", ".venv/**", "env/**", ".env/**",
            "*.egg-info/**", ".pytest_cache/**", ".mypy_cache/**", ".tox/**",
            ".coverage", "htmlcov/**",
            
            # Node.js / JavaScript
            "node_modules", "node_modules/**", ".next", ".next/**", ".nuxt/**", "out/**", "dist/**", "build/**",
            ".turbo/**", ".vercel/**", ".netlify/**", "coverage/**", ".nyc_output/**",
            
            # Lock files & large configs
            "package-lock.json", "pnpm-lock.yaml", "yarn.lock", "bun.lockb",
            "Pipfile.lock", "poetry.lock", "Cargo.lock", "package.json",
            
            # Cache and temporary
            ".cache/**", ".tmp/**", "tmp/**", ".DS_Store", "Thumbs.db", "*.log",
            
            # IDE and editor
            ".vscode/**", ".idea/**", "*.swp", "*.swo", "*~",
            
            # Build artifacts
            "target/**", "bin/**", "obj/**", "*.min.js", "*.min.css",
            
            # Large data files
            "*.csv", "*.tsv", "*.json.gz", "*.xml.gz"
        ]
    )


@dataclass
class FormatOptions:
    heading: str = "### {path}"
    fence_language_from_extension: bool = True
    preamble: str = (
        "This file was generated by flatcat.\n\n"
        "It contains a tree view and the full text contents of non-ignored files.\n"
    )


@dataclass
class Config:
    root: Path = Path(".")
    output: Path = Path("flatcat.md")
    include_tree: bool = True
    tree_depth: int = 0
    respect_gitignore: bool = True
    ignore_extensions: List[str] = field(
        default_factory=lambda: [
            # Images
            ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico", ".svg", ".webp", ".avif",
            # Videos  
            ".mp4", ".avi", ".mov", ".wmv", ".flv", ".webm", ".mkv",
            # Audio
            ".mp3", ".wav", ".flac", ".aac", ".ogg", ".m4a",
            # Archives
            ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz",
            # Executables
            ".exe", ".dll", ".so", ".dylib", ".app", ".deb", ".rpm", ".msi",
            # Documents (binary)
            ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
            # Fonts
            ".ttf", ".otf", ".woff", ".woff2", ".eot",
            # Other binary/large files
            ".bin", ".dat", ".db", ".sqlite", ".sqlite3", ".pem", ".key", ".crt", ".p12",
            # Compiled/generated files
            ".pyc", ".pyo", ".class", ".o", ".obj", ".lib", ".a"
        ]
    )
    filters: Filters = field(default_factory=Filters)
    format: FormatOptions = field(default_factory=FormatOptions)

    @classmethod
    def load(cls, path: Optional[Path]) -> "Config":
        if tomllib is None:
            # If TOML library isn't installed, just return default config.
            return cls()
        
        cfg_path = path or Path(DEFAULT_CONFIG)
        if not cfg_path.exists():
            return cls()
        
        try:
            with cfg_path.open("rb") as f:
                d = tomllib.load(f)
        except Exception:
            # If config is malformed, fall back to defaults
            return cls()
        
        def get_nested(keys, default):
            cur = d
            for k in keys:
                cur = cur.get(k, {})
            return cur if cur is not None else default
        
        # Create a default instance to get default values from
        defaults = cls()

        def _coerce_str(val, default):
            if isinstance(val, dict):
                return val.get("text", default)
            # allow False to disable preamble
            if isinstance(val, bool):
                return "" if val is False else default
            return val if isinstance(val, str) else default
        
        heading_val = get_nested(["format", "heading"], defaults.format.heading)
        preamble_val = get_nested(["format", "preamble"], defaults.format.preamble)

        return cls(
            root=Path(d.get("root", defaults.root)),
            output=Path(d.get("output", defaults.output)),
            include_tree=d.get("include_tree", defaults.include_tree),
            tree_depth=d.get("tree_depth", defaults.tree_depth),
            respect_gitignore=d.get("respect_gitignore", defaults.respect_gitignore),
            ignore_extensions=d.get("ignore_extensions", defaults.ignore_extensions),
            filters=Filters(
                include=get_nested(["filters", "include"], defaults.filters.include),
                exclude=get_nested(["filters", "exclude"], defaults.filters.exclude),
            ),
            format=FormatOptions(
                heading=_coerce_str(heading_val< defaults.format.heading),
                fence_language_from_extension=bool(
                    get_nested(["format", "fence_language_from_extension"],
                               defaults.format.fence_language_from_extension)
                ),
                preamble=_coerce_str(preamble_val, defaults.format.preamble),
            ),
        )
