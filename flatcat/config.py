from __future__ import annotations
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional

import sys

if sys.version_info >= (3, 11):
    import tomllib
else:
    import tomli as tomllib

DEFAULT_CONFIG = "flatcat.toml"


@dataclass
class Filters:
    include: List[str] = field(default_factory=list)
    exclude: List[str] = field(
        default_factory=lambda: [
    # Version control
    ".git/**", ".git", ".svn/**", ".svn", ".hg/**", ".hg",
    
    # Python
    "**/__pycache__/**", "__pycache__", 
    "venv/**", "venv", ".venv/**", ".venv", "env/**", "env", ".env/**",
    "*.egg-info/**", "*.egg-info",
    ".pytest_cache/**", ".pytest_cache", ".mypy_cache/**", ".mypy_cache",
    ".tox/**", ".tox", ".coverage", "htmlcov/**", "htmlcov",
    
    # Node.js / JavaScript
    "node_modules/**", "node_modules",
    ".next/**", ".next", ".nuxt/**", ".nuxt", 
    "out/**", "out", "dist/**", "dist", "build/**", "build",
    ".turbo/**", ".turbo", ".vercel/**", ".vercel", ".netlify/**", ".netlify",
    "coverage/**", "coverage", ".nyc_output/**", ".nyc_output",
    
    # Lock files (usually too large and not useful for LLMs)
    "package-lock.json", "pnpm-lock.yaml", "yarn.lock", "bun.lockb",
    "Pipfile.lock", "poetry.lock", "Cargo.lock",
    
    # Cache and temporary
    ".cache/**", ".cache", ".tmp/**", ".tmp", "tmp/**", "tmp",
    ".DS_Store", "Thumbs.db", "*.log",
    
    # IDE and editor
    ".vscode/**", ".vscode", ".idea/**", ".idea",
    "*.swp", "*.swo", "*~",
    
    # Build artifacts
    "target/**", "target", # Rust
    "bin/**", "obj/**", # .NET
    "*.min.js", "*.min.css", # Minified files
    
    # Large data files
    "*.csv", "*.tsv", "*.json.gz", "*.xml.gz"
]
    )


@dataclass
class FormatOptions:
    heading: str = "### {path}"
    fence_language_from_extension: bool = True
    preamble: str = (
        "This file was generated by flatcat.\n\n"
        "It contains a tree view of {root} and the full text contents of non-ignored files.\n"
    )


@dataclass
class Config:
    root: Path = Path(".")
    output: Path = Path("flatcat.md")
    include_tree: bool = True
    tree_depth: int = 0
    respect_gitignore: bool = True
    ignore_extensions: List[str] = field(
        default_factory=lambda: [
    # Images
    ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico", ".svg", ".webp", ".avif",
    # Videos  
    ".mp4", ".avi", ".mov", ".wmv", ".flv", ".webm", ".mkv",
    # Audio
    ".mp3", ".wav", ".flac", ".aac", ".ogg", ".m4a",
    # Archives
    ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz",
    # Executables
    ".exe", ".dll", ".so", ".dylib", ".app", ".deb", ".rpm", ".msi",
    # Documents (binary)
    ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
    # Fonts
    ".ttf", ".otf", ".woff", ".woff2", ".eot",
    # Other binary/large files
    ".bin", ".dat", ".db", ".sqlite", ".sqlite3", ".pem", ".key", ".crt", ".p12",
    # Compiled/generated files
    ".pyc", ".pyo", ".class", ".o", ".obj", ".lib", ".a"
]
    )
    filters: Filters = field(default_factory=Filters)
    format: FormatOptions = field(default_factory=FormatOptions)

    @classmethod
    def load(cls, path: Optional[Path]) -> "Config":
        cfg_path = path or Path(DEFAULT_CONFIG)
        if not cfg_path.exists():
            return cls()
        
        with cfg_path.open("rb") as f:
            d = tomllib.load(f)
        
        def get_nested(keys, default):
            cur = d
            for k in keys:
                cur = cur.get(k, {})
            return cur or default
        
        return cls(
            root=Path(d.get("root", ".")),
            output=Path(d.get("output", "flatcat.md")),
            include_tree=d.get("include_tree", True),
            tree_depth=d.get("tree_depth", 0),
            respect_gitignore=d.get("respect_gitignore", True),
            ignore_extensions=d.get("ignore_extensions", cls().ignore_extensions),
            filters=Filters(
                include=get_nested(["filters", "include"], []),
                exclude=get_nested(["filters", "exclude"], cls().filters.exclude),
            ),
            format=FormatOptions(
                heading=get_nested(["format", "heading"], cls().format.heading),
                fence_language_from_extension=get_nested(
                    ["format", "fence_language_from_extension"],
                    cls().format.fence_language_from_extension,
                ),
                preamble=get_nested(["format", "preamble"], cls().format.preamble),
            ),
        )
    
    def override(
            self,
            root: Optional[Path] = None,
            output: Optional[Path] = None,
            include_tree: Optional[bool] = None,
    ) -> "Config":
        if root is not None:
            self.root = root
        if output is not None:
            self.output = output
        if include_tree is not None:
            self.include_tree = include_tree
        return self
